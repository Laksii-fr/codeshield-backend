import asyncio
from typing import List, Dict, Any
from openai import OpenAI
from app.config import settings
from app.schemas import Vulnerability, VulnerabilityScanResult, VulnerabilityAnalysisResponse

# Constants
MAX_CHUNKS_PER_BATCH = 5

# Initialize OpenAI client
_client = None

def get_openai_client() -> OpenAI:
    """Get or create OpenAI client instance."""
    global _client
    if _client is None:
        _client = OpenAI(api_key=settings.OPENAI_API_KEY)
    return _client


def create_analysis_prompt(code_chunk: Dict[str, Any]) -> str:
    """
    Creates a prompt for vulnerability analysis.
    
    Args:
        code_chunk: Dictionary containing chunk information
    
    Returns:
        Formatted prompt string
    """
    code_snippet = code_chunk.get('code_snippet', '')
    file_path = code_chunk.get('file_path', '')
    start_line = code_chunk.get('start_line', 0)
    end_line = code_chunk.get('end_line', 0)
    
    prompt = f"""You are a senior security expert analyzing code for vulnerabilities. Analyze the following code snippet for security vulnerabilities.

File: {file_path}
Lines: {start_line}-{end_line}

Code:
{code_snippet}

Please identify all security vulnerabilities in this code. Focus on:
1. Injection vulnerabilities (SQL, NoSQL, Command, LDAP, etc.)
2. Authentication and authorization flaws
3. Sensitive data exposure
4. XML External Entities (XXE)
5. Broken access control
6. Security misconfiguration
7. Cross-Site Scripting (XSS)
8. Insecure deserialization
9. Using components with known vulnerabilities
10. Insufficient logging and monitoring
11. Cryptographic failures
12. Server-Side Request Forgery (SSRF)
13. Race conditions
14. Path traversal
15. Insecure random number generation
16. Hardcoded secrets/credentials
17. Insecure direct object references

For each vulnerability found, provide:
- Vulnerability type
- Severity (Critical, High, Medium, Low, Info)
- Exact line numbers
- Detailed description
- The vulnerable code snippet
- Specific recommendation to fix it
- CWE ID if applicable
- OWASP Top 10 category if applicable

If no vulnerabilities are found, return an empty vulnerabilities array."""
    
    return prompt


async def analyze_chunk(code_chunk: Dict[str, Any]) -> VulnerabilityScanResult:
    """
    Analyze a single code chunk for vulnerabilities using OpenAI Responses API.
    
    Args:
        code_chunk: Dictionary containing chunk information
    
    Returns:
        VulnerabilityScanResult with findings
    """
    try:
        prompt = create_analysis_prompt(code_chunk)
        client = get_openai_client()
        
        # Run synchronous client.responses.parse() in executor for async compatibility
        loop = asyncio.get_event_loop()
        response = await loop.run_in_executor(
            None,
            lambda: client.responses.parse(
                model=settings.OPENAI_MODEL,
                input=[
                    {
                        "role": "system",
                        "content": [
                            {
                                "type": "input_text",
                                "text": (
                                    "You are a security expert specializing in code vulnerability analysis. "
                                    "Always provide accurate, detailed vulnerability assessments. "
                                    "Analyze the provided code for security vulnerabilities and return your findings "
                                    "in the structured format matching the schema."
                                    "In Vibe Coder Explaination Provide explanation in a way that is easy to understand and follow. Easy for vibe coders to understand and fix the vulnerabilities."
                                )
                            }
                        ]
                    },
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "input_text",
                                "text": prompt
                            }
                        ]
                    }
                ],
                text_format=VulnerabilityAnalysisResponse
            )
        )
        
        # Get parsed response
        parsed_response = response.output_parsed
        
        # Convert to Vulnerability objects and ensure file_path is set
        vulnerabilities = []
        chunk_file_path = code_chunk.get('file_path', '')
        
        for vuln in parsed_response.vulnerabilities:
            try:
                # Ensure file_path is set from chunk if not in response
                vuln_dict = vuln.model_dump()
                if not vuln_dict.get('file_path'):
                    vuln_dict['file_path'] = chunk_file_path
                
                # Create new Vulnerability with updated file_path
                vulnerability = Vulnerability(**vuln_dict)
                vulnerabilities.append(vulnerability)
            except Exception as e:
                print(f"[VULN_DETECTOR] Warning: Failed to process vulnerability: {e}")
                continue
        
        return VulnerabilityScanResult(
            chunk_id=code_chunk.get('chunk_id', 0),
            file_path=code_chunk.get('file_path', ''),
            vulnerabilities=vulnerabilities,
            scan_status="completed"
        )
        
    except Exception as e:
        print(f"[VULN_DETECTOR] Error analyzing chunk {code_chunk.get('chunk_id', 'unknown')}: {str(e)}")
        return VulnerabilityScanResult(
            chunk_id=code_chunk.get('chunk_id', 0),
            file_path=code_chunk.get('file_path', ''),
            vulnerabilities=[],
            scan_status="error",
            error_message=str(e)
        )


async def analyze_chunks_batch(chunks: List[Dict[str, Any]]) -> List[VulnerabilityScanResult]:
    """
    Analyze multiple chunks in parallel batches.
    
    Args:
        chunks: List of code chunk dictionaries
    
    Returns:
        List of VulnerabilityScanResult objects
    """
    results = []
    
    # Process chunks in batches to avoid overwhelming the API
    for i in range(0, len(chunks), MAX_CHUNKS_PER_BATCH):
        batch = chunks[i:i + MAX_CHUNKS_PER_BATCH]
        print(f"[VULN_DETECTOR] Processing batch {i//MAX_CHUNKS_PER_BATCH + 1} ({len(batch)} chunks)")
        
        # Process batch in parallel
        batch_tasks = [analyze_chunk(chunk) for chunk in batch]
        batch_results = await asyncio.gather(*batch_tasks, return_exceptions=True)
        
        # Handle any exceptions
        for idx, result in enumerate(batch_results):
            if isinstance(result, Exception):
                print(f"[VULN_DETECTOR] Error in batch processing: {result}")
                results.append(VulnerabilityScanResult(
                    chunk_id=batch[idx].get('chunk_id', 0),
                    file_path=batch[idx].get('file_path', ''),
                    vulnerabilities=[],
                    scan_status="error",
                    error_message=str(result)
                ))
            else:
                results.append(result)
        
        # Small delay between batches to respect rate limits
        if i + MAX_CHUNKS_PER_BATCH < len(chunks):
            await asyncio.sleep(1)
    
    return results


async def analyze_repository(chunks: List[Dict[str, Any]]) -> List[VulnerabilityScanResult]:
    """
    Analyze all chunks from a repository.
    
    Args:
        chunks: List of all code chunks from the repository
    
    Returns:
        List of VulnerabilityScanResult objects
    """
    print(f"[VULN_DETECTOR] Starting vulnerability analysis for {len(chunks)} chunks")
    
    if not chunks:
        return []
    
    results = await analyze_chunks_batch(chunks)
    
    total_vulns = sum(len(r.vulnerabilities) for r in results)
    print(f"[VULN_DETECTOR] Analysis complete. Found {total_vulns} vulnerabilities across {len(results)} chunks")
    
    return results
